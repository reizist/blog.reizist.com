<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reizist&#39;s memo &middot; reizist&#39;s memo</title>

    <meta name="description" content="reizist&#39;s daily memo">

    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="reizist" />
    <meta name="twitter:title" content="reizist&#39;s memo &middot; reizist&#39;s memo">
    <meta name="twitter:description" content="reizist&#39;s daily memo">

    <meta property="og:type" content="article">
    <meta property="og:title" content="reizist&#39;s memo &middot; reizist&#39;s memo">
    <meta property="og:description" content="reizist&#39;s daily memo">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">

    <link rel="stylesheet" href='https://blog.reizist.com/css/all.min.css'>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="reizist&#39;s memo" href='https://blog.reizist.com/index.xml' />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://blog.reizist.com/">reizist&#39;s memo</a></h1>
            <h2 class="brand-tagline"> reizist&#39;s daily memo </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/reizist">
                        <i class="fa fa-twitter"></i> Twitter
                    </a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/reizist">
                        <i class="fa fa-github-alt"></i> Github
                    </a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://stackoverflow.com/u/8758262">
                        <i class="fa fa-stack-overflow"></i>Stack Overflow
                    </a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href='https://blog.reizist.com/index.xml'>
                        <i class="fa fa-rss"></i> rss
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">05 Mar 2021, 20:37</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.reizist.com/post/change-bq-schema/" class="post-title">BigQueryでカラムの型を変更する</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<p>BigQueryのWeb Console上からは一度定義したテーブルのスキーマ情報は更新ができず、カラム追加のみ可能となっている。</p>

<p>が、カラムの型を変更するときのオペレーションをさっくりメモ。</p>

<p>Doc は <a href="https://cloud.google.com/bigquery/docs/manually-changing-schemas">https://cloud.google.com/bigquery/docs/manually-changing-schemas</a> にある。</p>

<h2 id="1-バックアップ">1. バックアップ</h2>

<pre><code>bq cp --project_id target_project_id -f target_dataset.target_table target_dataset.target_table_copy
</code></pre>

<h2 id="2-型変換">2. 型変換</h2>

<pre><code>bq query --project_id target_project_id --destination_table target_dataset.target_table --replace --use_legacy_sql=false 'SELECT
  * EXCEPT(target_column),
  CAST(target_column AS TARGET_TYPE) AS target_column
FROM
  target_dataset.target_table where _PARTITIONDATE&gt;&quot;2015-01-01&quot;'
</code></pre>

<h2 id="3-バックアップ消去">3. バックアップ消去</h2>

<pre><code>bq rm --project_id target_project_id target_dataset.target_table_copy
</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">14 Oct 2020, 19:28</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.reizist.com/post/display-arm/" class="post-title">ディスプレイ環境2020</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="http://reizist.hatenablog.com/entry/2017/03/03/044202">http://reizist.hatenablog.com/entry/2017/03/03/044202</a></p>

<p>Philips の4Kディスプレイ<a href="https://www.amazon.co.jp/exec/obidos/ASIN/B01D9FP20A/reiji012-22/">BDM4350UC/11</a>を使っているが、脚の高さが足りず、Macbookのディスプレイを見る必要があるとき(主にリモート環境で通話を行う場合: 頻度はほぼ毎日)にディスプレイの下半分が見えず不便している。</p>

<p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">display環境2020（しばらくアップデートなし）なんだけどなんか改善したくなってきた。<br>4Kディスプレイ底上げしたいソリューション is 何 <a href="https://t.co/KwOBAevLIv">pic.twitter.com/KwOBAevLIv</a></p>&mdash; reizist (@reizist) <a href="https://twitter.com/reizist/status/1316308402583134209?ref_src=twsrc%5Etfw">October 14, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>モニターアームを買うことで解決しようとしている。</p>

<p><a href="https://www.amazon.co.jp/dp/B00MIBN16O">Amazonベーシックモニターアーム</a>が良さそうという情報を得た。</p>

<p>これは<a href="https://www.amazon.co.jp/gp/product/B00358RIRC/">エルゴトロンLX</a>のOEMで本家よりも少し安く、セール時には8000円未満で買えるらしい。在庫復活はよ</p>

<p>BDM4350UC/11 の場合、
<a href="https://www.amazon.co.jp/%E3%82%B5%E3%83%B3%E3%82%B3%E3%83%BC-MARMVESA200-VESA%E5%A4%89%E6%8F%9B%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88200x200/dp/B00LCKZ79Q/ref=pd_lpo_147_t_1/357-6167182-3768459?_encoding=UTF8&amp;pd_rd_i=B00LCKZ79Q&amp;pd_rd_r=e1bc60cf-d64b-4486-a940-2003bd391f09&amp;pd_rd_w=csGmN&amp;pd_rd_wg=XoHne&amp;pf_rd_p=4b55d259-ebf0-4306-905a-7762d1b93740&amp;pf_rd_r=P8CY20JX22E44JVB981M&amp;psc=1&amp;refRID=P8CY20JX22E44JVB981M">VESA変換プレート</a>が必要になりそうなので合わせて購入する。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">09 Jun 2020, 10:50</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.reizist.com/post/datalake-s3-export-rds/" class="post-title">Datalake S3 Export Rds</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>データレイクをどうするかを考える機会があったのでシュッとメモ :memo:</p>

<p>現在データマートを作るための、生データの参照先として、日時でとったsnapshotからrestoreしたDBを構築している(レポーティングDBと呼称している TODO: レポーティングDBとよんでいる理由?)。
が、DBのrunning costも馬鹿にならないし、マイクロサービスの文脈でボンボン新たなDBが映えるたびに1:1でレポーティングDBをボンボン増やすのもなぁ、ということで、S3をデータレイクにするパターンを検証した。</p>

<p>検証といってもやったことは単純で、<a href="https://aws.amazon.com/jp/about-aws/whats-new/2020/01/announcing-amazon-relational-database-service-snapshot-export-to-s3/">今年1月に発表されたRDS snapshotをS3にエクスポートする機能</a>を使い、snapshotをparquet化。
Glueクローラを用いてS3からスキーマ検出/Athena上でテーブル化された状態で<a href="https://github.com/shinji19/embulk-input-athena">embulk-input-athena</a>を用いてBQに投げることができるのを確認した。</p>

<p>唯一ハマったのは、S3へのexport時デフォルトでKMSによって暗号化されているためS3を参照するロールにKMSのDecrypt権限 <code>&quot;kms:Decrypt&quot;</code> が必要になる点。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">08 Nov 2018, 02:17</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://blog.reizist.com/post/output-coverage-slack/" class="post-title">test coverageをcircleciでoutputするようにした</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>test coverageをcircleciでoutputするようにした。
所属チームの他のコンポーネントでテスト的に無料枠のCodecovを使っていて、
自分がメインで見ているrailsプロダクトにもcoverageを意識的に見る文化を取り入れたいと思ったものの
Codecovを最初から有料枠にするのも気が引けたので無料でできる範囲から。</p>

<p>やったことはほぼ <a href="https://qiita.com/u-minor/items/c18f0f03a9255f9e5231">https://qiita.com/u-minor/items/c18f0f03a9255f9e5231</a> の通りで、</p>

<p>多少アレンジしている。
circleciでの設定はrun section追加するだけで、プロジェクトの <code>bin/</code> に放り込んだshell scriptを実行しているだけ。</p>

<pre><code class="language-yml:config.yml">- run:
    name: Post coverage
    command: bin/post-coverage-to-slack
</code></pre>

<pre><code class="language-sh">###
# original: https://gist.githubusercontent.com/u-minor/8cb27fa9c04163142ebd/raw/circleci-coverage-slack
# Post coverage rate to Slack
#
# Usage: bash circleci-coverage-slack.sh [cobertura|jacoco]
#
# Required environment variables:
#
# - CIRCLE_TOKEN: project-specific readonly API token (need to access build artifacts for others)
# - SLACK_ENDPOINT: Slack endpoint url
# - COVERAGE_FILE: coverage xml filename (default: coverage.xml)
# - MAX_BUILD_HISTORY: max history num to fetch old rate (default: 5)
#

function calcCoberturaRate() {
  local rate=$(ruby -r &quot;rexml/document&quot; -e '
node = REXML::XPath.first(REXML::Document.new(STDIN.read), &quot;coverage&quot;)
puts &quot;%.2f&quot; % (node.attributes[&quot;line-rate&quot;].to_f * 100)
')
  [ &quot;$rate&quot; == &quot;100.00&quot; ] &amp;&amp; rate=100
  echo $rate
}

function calcJacocoRate() {
  local rate=$(ruby -r &quot;rexml/document&quot; -e '
node = REXML::XPath.first(REXML::Document.new(STDIN.read), &quot;report/counter[@type=\&quot;LINE\&quot;]&quot;)
missed = node.attributes[&quot;missed&quot;].to_f
covered = node.attributes[&quot;covered&quot;].to_f
puts &quot;%.2f&quot; % (covered / (covered + missed) * 100)
')
  [ &quot;$rate&quot; == &quot;100.00&quot; ] &amp;&amp; rate=100
  echo $rate
}

function calcRate() {
  case &quot;$coverage_type&quot; in
    &quot;cobertura&quot; )
      calcCoberturaRate
      ;;
    &quot;jacoco&quot; )
      calcJacocoRate
      ;;
  esac
}

coverage_type=${1:-cobertura}
coverage=$(find $CIRCLE_ARTIFACTS -type f | grep ${COVERAGE_FILE:-coverage.xml})
url_base=&quot;https://circleci.com/api/v1/project/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}&quot;

## calculate rates
rate_new=$(cat $coverage | calcRate)
rate_old=0
for build_num in $(echo $CIRCLE_PREVIOUS_BUILD_NUM; seq $(expr $CIRCLE_BUILD_NUM - 1) -1 1 | head -n ${MAX_BUILD_HISTORY:-5}); do
  echo &quot;fetching coverage info for build:${build_num} ...&quot;
  artifacts=&quot;${url_base}/${build_num}/artifacts&quot;
  [ -n &quot;$CIRCLE_TOKEN&quot; ] &amp;&amp; artifacts=&quot;${artifacts}?circle-token=${CIRCLE_TOKEN}&quot;
  coverage=$(curl -s -H 'Accept: application/json' $artifacts | jq -r '.[].url' | grep ${COVERAGE_FILE:-coverage.xml})
  coverage_html=$(curl -s -H 'Accept: application/json' $artifacts | jq -r '.[].url' | grep index.html)
  [ -n &quot;$coverage&quot; ] &amp;&amp; break
done
if [ -n &quot;$coverage&quot; ]; then
  [ -n &quot;$CIRCLE_TOKEN&quot; ] &amp;&amp; coverage=&quot;${coverage}?circle-token=${CIRCLE_TOKEN}&quot;
  rate_old=$(curl -s $coverage | calcRate)
fi

## construct messages
author=$(git log --format='%an &lt;%ae&gt;' -1 | sed 's/\\/\\\\/g;s/\&quot;/\\&quot;/g')
log=$(git log --format=%s -1 | sed 's/\\/\\\\/g;s/\&quot;/\\&quot;/g')
mode=$(ruby -e 'puts (ARGV[0].to_f &lt;=&gt; ARGV[1].to_f) + 1' -- $rate_new $rate_old)
mes=(&quot;DECREASED&quot; &quot;NOT CHANGED&quot; &quot;INCREASED&quot;)
color=(&quot;danger&quot; &quot;#a0a0a0&quot; &quot;good&quot;)
cat &gt; .slack_payload &lt;&lt;_EOT_
{
  &quot;attachments&quot;: [
    {
      &quot;fallback&quot;: &quot;Coverage ${mes[$mode]} (${rate_new}%)&quot;,
      &quot;text&quot;: &quot;*${mes[$mode]}* (${rate_old}% -&gt; ${rate_new}%) &lt;${coverage_html}&gt;&quot;,
      &quot;pretext&quot;: &quot;Coverage report: &lt;https://circleci.com/gh/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BUILD_NUM}|#${CIRCLE_BUILD_NUM}&gt; &lt;https://circleci.com/gh/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}|${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}&gt; (&lt;https://circleci.com/gh/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/tree/${CIRCLE_BRANCH}|${CIRCLE_BRANCH}&gt;)&quot;,
      &quot;color&quot;: &quot;${color[$mode]}&quot;,
      &quot;mrkdwn_in&quot;: [&quot;pretext&quot;, &quot;text&quot;, &quot;fields&quot;],
      &quot;fields&quot;: [
        {
          &quot;value&quot;: &quot;Commit: &lt;https://github.com/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/commit/${CIRCLE_SHA1}|${CIRCLE_SHA1}&gt;&quot;,
          &quot;short&quot;: false
        },
        {
          &quot;value&quot;: &quot;Author: ${author}&quot;,
          &quot;short&quot;: false
        },
        {
          &quot;value&quot;: &quot;${log}&quot;,
          &quot;short&quot;: false
        }
      ]
    }
  ]
}
_EOT_

## post to slack
curl -s --data-urlencode payload@.slack_payload ${SLACK_ENDPOINT}
rm .slack_payload
</code></pre>

<p>変更したのは1点で、corbetura formatとは別にhtml formatも出力するようにしておいて、circleciのattachmentにlinkを追加している。
今まではsimplecov というgemを使ってcircleciでartifactとしてuploadするのみだったので、実際にgithubで開発をしていると、</p>

<ol>
<li>github pushするとintegrationによりcircleci buildが実行される</li>
<li>build完了時、PRにその結果が通知される</li>
<li>通知されたpostからcircleciのリンクをたどり該当のbuild結果からartifactのタブを選択</li>
<li>該当のhtmlをクリック</li>
</ol>

<p>という手順が必要で、何が言いたいかというとcoverageの詳細を確認する手順が多かった。</p>

<p>少しでもアクセスしにくいと感じると人間は低きに流れるのでチェックする習慣は無くなってしまうと思う。</p>

<p>のでpercentage of coverageをpostしcoverageを意識させつつ詳細を見やすくした、というのが今回の対応です。</p>

<p><img src="/output-coverage-slack/simplecov.png" alt="" class="pure-img" ></p>

<p>尚このためにsimplecovの設定としてはMultiFormatterを使っていて</p>

<pre><code class="language-rb">require 'simplecov'
require 'simplecov-cobertura'

SimpleCov.formatters = SimpleCov::Formatter::MultiFormatter.new(
  [
    SimpleCov::Formatter::HTMLFormatter,
    SimpleCov::Formatter::CoberturaFormatter
  ]
)
</code></pre>

<p>によってcorbeturaとhtmlを <code>coverage/</code> に出力している。</p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="https://gohugo.io/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src='https://blog.reizist.com/js/all.min.js'></script>

        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
